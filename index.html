<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kingdoms 4X Lab</title>
  <style>
    body { margin:0; font-family:system-ui; }
    #top { padding:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { padding:10px 12px; border-radius:12px; border:1px solid #ccc; background:#fff; }
    #info { padding: 0 10px 10px 10px; }
    canvas { width:100vw; height: calc(100vh - 110px); display:block; background:#fafafa; }
  </style>
</head>
<body>
  <div id="top">
    <div id="status">Loading…</div>
    <button id="end">End Turn</button>
  </div>
  <div id="info">Click tiles. We’ll add tech, buildings, units next.</div>
  <canvas id="c"></canvas>

<script>
const RULES = { radius: 5 };

const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = Math.floor(innerWidth * devicePixelRatio);
  canvas.height = Math.floor((innerHeight - 110) * devicePixelRatio);
  draw();
}
addEventListener("resize", resize);

const HEX_DIRS = [[+1,0],[+1,-1],[0,-1],[-1,0],[-1,+1],[0,+1]];
const tiles = [];
function inBounds(q,r,rad){
  const s = -q-r;
  return Math.max(Math.abs(q),Math.abs(r),Math.abs(s))<=rad;
}
for(let q=-RULES.radius;q<=RULES.radius;q++){
  for(let r=-RULES.radius;r<=RULES.radius;r++){
    if(!inBounds(q,r,RULES.radius)) continue;
    tiles.push({q,r, terrain: Math.random()<0.15 ? "water":"land"});
  }
}

function hexSize(){ return Math.min(canvas.width, canvas.height) / (RULES.radius*2.7); }
function hexToPixel(q,r){
  const s = hexSize();
  const x = s*(Math.sqrt(3)*q + Math.sqrt(3)/2*r) + canvas.width/2;
  const y = s*(3/2*r) + canvas.height/2;
  return [x,y];
}
function drawHex(cx,cy,size){
  ctx.beginPath();
  for(let i=0;i<6;i++){
    const ang = (Math.PI/180)*(60*i-30);
    const x = cx + size*Math.cos(ang);
    const y = cy + size*Math.sin(ang);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
}

let turn=1;
let selected=null;

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const s = hexSize();
  for(const t of tiles){
    const [x,y] = hexToPixel(t.q,t.r);
    drawHex(x,y,s*0.98);
    ctx.fillStyle = (t.terrain==="water") ? "#dff3ff" : "#f6f6f6";
    ctx.fill();
    ctx.lineWidth = 2*devicePixelRatio;
    ctx.strokeStyle = "#e5e5e5";
    ctx.stroke();
    if(selected && selected.q===t.q && selected.r===t.r){
      ctx.lineWidth = 4*devicePixelRatio;
      ctx.strokeStyle = "#111";
      ctx.stroke();
    }
    ctx.fillStyle="#111";
    ctx.font = `${10*devicePixelRatio}px system-ui`;
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(`${t.q},${t.r}`, x, y);
  }
  document.getElementById("status").textContent = `Turn ${turn} | Selected: ${selected ? `${selected.q},${selected.r}` : "none"}`;
}

canvas.addEventListener("pointerdown", (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) * devicePixelRatio;
  const y = (ev.clientY - rect.top) * devicePixelRatio;

  // brute: find closest tile center
  let best=null, bestD=1e18;
  for(const t of tiles){
    const [tx,ty] = hexToPixel(t.q,t.r);
    const d = (tx-x)*(tx-x) + (ty-y)*(ty-y);
    if(d<bestD){ bestD=d; best=t; }
  }
  selected = best;
  draw();
});

document.getElementById("end").onclick = ()=>{
  turn++;
  draw();
};

resize();
</script>
</body>
</html>
